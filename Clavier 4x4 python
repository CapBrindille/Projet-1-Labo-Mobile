import RPi.GPIO as GPIO
import time

# Définition des broches GPIO utilisées
LIGNES = [6, 13, 19, 26]  # GPIO des lignes
COLONNES = [12, 16, 20, 21]  # GPIO des colonnes

# Mappage des touches
TOUCHES = [
    ['1', '2', '3', 'A'],
    ['4', '5', '6', 'B'],
    ['7', '8', '9', 'C'],
    ['*', '0', '#', 'D']
]

# Configuration des GPIO
GPIO.setmode(GPIO.BCM)

# Configuration des broches lignes en entrées avec pull-up
for ligne in LIGNES:
    GPIO.setup(ligne, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Configuration des broches colonnes en sorties
for colonne in COLONNES:
    GPIO.setup(colonne, GPIO.OUT)
    GPIO.output(colonne, 1)  # Colonnes à l'état haut

def lire_clavier():
    """Lit les touches pressées sur le clavier matriciel"""
    for c in range(4):  # Balayage des colonnes
        GPIO.output(COLONNES[c], 0)  # Active la colonne
        for l in range(4):  # Vérifie chaque ligne
            if GPIO.input(LIGNES[l]) == 0:  # Si la ligne passe à LOW, touche pressée
                print("Touche pressée :", TOUCHES[l][c])
                while GPIO.input(LIGNES[l]) == 0:  # Attente du relâchement
                    time.sleep(0.1)
        GPIO.output(COLONNES[c], 1)  # Désactive la colonne

# Boucle principale
try:
    print("Appuyez sur une touche...")
    while True:
        lire_clavier()
        time.sleep(0.1)  # Petite pause pour éviter les rebonds

except KeyboardInterrupt:
    print("\nArrêt du programme.")
    GPIO.cleanup()  # Nettoyage des GPIO
